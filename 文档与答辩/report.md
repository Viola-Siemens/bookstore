#项目概述

###实现一个提供网上购书、售书功能的网站后端。

# 第一部分——前期准备

- 下载PostgreSQL，创建用户名root，密码为123456，并赋予root创建、修改、删除数据库的权限；

- 使用root在PostgreSQL中创建名为bookstore的数据库；

-  安装依赖：

  ```
  pip install -r requirements.txt
  ```

  

- 执行测试：

  ```
  bash script/test.sh
  ```

  

#第二部分——数据库设计

##ER图

![3906DABACA2E881EF0F6972AC6DC6B31](https://s3.ax1x.com/2021/01/12/sYsqs0.jpg)



##关系模式、索引设计以及规范化

#####详情见schema.pdf

###search搜索图书功能

####多关键词搜索

提供针对标题、内容、出版社的多关键字部分匹配查询和针对标签的多关键字准确查询。最终返回各类目中均满足至少一个关键字的结果，同时允许缺省一部分类别的关键字。

由于允许多关键字查询，采用字符串拼接的形式生成查询语句，对于每个类目，如果得到的关键词列表非空，则调用函数生成查询条件，其具体代码如下：

```python
"""
attribute:查询的属性
keywords:关键词列表
pre_dict:关键词的映射关系
"""
def get_like_predicate(self, attribute, keywords, pre_dict):
        ans = []
        for kw in keywords:
            cnt = len(pre_dict)
            pre = 'pre_' + str(cnt)
            ans.append("{} like concat('%%',%({})s,'%%')".format(attribute, pre))
            pre_dict[pre] = kw
        return '(' + ' or '.join(ans) + ')'
```

可以看到，为了提高命中率，查询条件使用like字句，允许关键词和目标进行不完全匹配。同时，为了防止注入，采用了参数传递的方式进行构造，具体见防注入部分。

对于标签，由于书籍信息允许多标签，在schema中采用了一张表存放这一关系。在进行查询时，采用连接的形式进行查询。因为同样允许多关键字查询，依然是采用字符串拼接的形式生成查询条件，代码如下：

```python
def get_tag_predicate(self, attribute, keywords, pre_dict):
        ans = []
        for kw in keywords:
            cnt = len(pre_dict)
            pre = 'pre_' + str(cnt)
            pre_dict[pre] = kw
            ans.append("tag = %({})s".format(pre))

        return 'book_tag.id = book_info.id and (' + ' or '.join(ans) + ')'
```

搜索的开销相对较大，考虑到连接标签表部分，由于标签带有索引，开销较小，大致上需要全局遍历书籍信息表的复杂度开销。如果是店内搜索，由于店铺id上建有索引，开销能有较为明显的下降。但如果是全场搜索，开销较大，据测试，使用数据集`book.db`填充数据库时，查询耗时约0.5s（含前后端交互延迟）。使用数据集`book_lx.db`时，查询耗时根据关键词的数量大约在0.5-2s之间。由于一般查询的关键词不会很多，正常查询的耗时大约在一秒左右。这个开销相对而言是可以接受的。

一个有效的减小搜索开销的方法是建立倒排索引，但考虑实际因素，暂不在项目中建立倒排索引。原因如下：

1. 常规的倒排索引保存在内存中，但因为笔记本电脑的内存有限，在内存中保存倒排索引不现实。据测试，构建约2万篇文档的倒排索引就已经因内存换页导致了明显的延时。所以可以推测，对于有4万本书的多个倒排索引，在本机内存的基础上进行构建是不大可能的。
2. 作为替代方案，可以在数据库中构建索引表。但在项目中，为了保证前后互不干扰，每次启动服务器时，我们会清空数据库。而我们无法一直保持服务器开启，所以会在进行开发测试的时候才开启服务器。因此，每次开启服务器，重新构建数据库时，需要重新根据书籍信息构建索引表。然而构建索引表的开销较大，在这种需要短时间反复构建的情况下耗时

####游标

为了减少服务器和数据库间的通讯开销，这里使用游标`cursor`进行读取，对于每次查询，只返回一部分的结果。前端的查询请求需要包含一个页码，后端在完成查询后，不直接将所有结果取出，而是通过游标获取结果，根据页码移动游标，只取出对应页码内的搜索结果。这样可以防止在查询结果较多时服务器和数据库间通讯的压力过大造成阻塞，从而降低查询的开销。代码如下：

```python
self.cursor.execute(sql, pre_dict)
self.cursor.scroll(page_id * 30)

result = [self.trans_result(x) for x in self.cursor.fetchmany(30)]
```

####防注入

在实际应用场景中，SQL注入是一种常见的攻击手段。针对SQL注入，有很多种防御的方法。由于本项目实现采用的是`SQLAlchemy`这一框架，一般的查询都是使用orm进行操作，由框架自带的绑定机制即可完成对注入的防御。但对于搜索查询，由于使用字符串拼接的方式，无法直接使用orm进行操作，故采用`psycopg2`的参数化传递方法，使用参数传递的方法生成查询。与一般的字符串拼接生成查询的方式不同，使用参数化传递进行拼接时，不直接拼接关键词信息，而是维护一个关键词和代号的映射表，只在查询语句中嵌入代号。再由引擎读取映射表，进行拼接，从而防止恶意参数对查询语句造成影响。



# 第三部分——功能实现与性能分析

###功能实现与性能分析

####auth功能

- 注册

  - 根据user_id判断该用户名是否已经存在。
  - 插入user_id、password、balance、token、termial信息至usr表。

  **性能分析：**
  usr表一次根据主键查询，一次插入。

- 登录

  - 根据user_id获取用户密码。
  - 检查密码正确与否
  - 更新token，terminal值。

  **性能分析：**
  usr表一次根据主键查询，一次更新。

- 登出

  - 根据user_id查询该user是否处于登陆状态。
  - 更新token。

  **性能分析：**
  usr表一次根据主键查询，一次更新。



- 注销

  - 根据user_id查询该user是否存在。
  - 删除对应user表中条目。

  **性能分析：**
  usr表一次根据主键查询，一次删除。



- 更改密码

  - 根据user_id获取用户原有密码。
  - 与用户输入的旧密码对比。
  - 若相同，更新用户密码。

  **性能分析：**
  usr表一次根据主键查询，一次更新。



####seller功能

1. 上架书籍

   1. 检查用户、店铺、书籍信息是否存在
   2. 添加基础书籍信息
   3. 添加图片信息
   4. 添加标签信息

   性能分析

   检查信息是否存在，共3次查询，对应的查询属性都有索引，所以开销是常数级的；添加基础信息1次查询；添加图片和标签信息的查询数量取决于图片数和标签数，大致可以认为是较小的常数。故总查询开销是$O(1)$级别的。

2. 创建店铺

   1. 检查用户和店铺信息是否存在
   2. 添加店铺信息

   性能分析

   检查信息是否存在，共2次查询，对应的查询属性都有索引，所以开销是常数级的；添加店铺信息1次查询。故总开销是$O(1)$级别的。

3. 增加库存

   1. 查询用户、店铺、书籍信息是否存在
   2. 增加库存

   性能分析

   检查信息是否存在，共3次查询，对应的查询属性都有索引，所以开销是常数级的；增加库存1次查询。故总开销是$O(1)$级别的。

4. 发货：

   i. 判断user\_id和order\_id是否存在，且商铺的开店者为该用户、订单状态为已付款，根据user\_id获取用户密码，并于用户输入密码对比。

   ii. 若存在且合法，则将订单状态设为已发货。

####buyer功能

1. 下单：

    i. 判断user\_id是否存在，根据user\_id获取用户密码，并于用户输入密码对比。

   ii. 若存在且密码相同，查询所有下单物品与价格，并向数据库创建记录。

2. 充值：

   i. 判断user\_id是否存在，根据user\_id获取用户密码，并于用户输入密码对比。

   ii. 若存在且密码相同，则更新用户余额。

3. 付款：

   i. 判断user\_id和order\_id是否存在，且下单者为该用户、订单状态为待付款，根据user\_id获取用户密码，并于用户输入密码对比。

   ii. 若存在且合法，更新用户余额。

   iii. 若更新成功（即余额充足），则将订单状态设为已付款待发货，否则回滚。

4. 收货：

   i. 判断user\_id和order\_id是否存在，且下单者为该用户、订单状态为已发货，根据user\_id获取用户密码，并于用户输入密码对比。

   ii. 若存在且合法，则将订单状态设为已收货。

5. 取消订单：

   i. 判断user\_id和order\_id是否存在，且下单者为该用户、订单状态为待付款，根据user\_id获取用户密码，并于用户输入密码对比。

   ii. 若存在且合法，则将订单状态设为已取消。

6. 历史订单查询：

   i. 判断user\_id是否存在，根据user\_id获取用户密码，并于用户输入密码对比。

   ii. 若存在且密码相同，则查询所有下单者为该用户的订单，并返回给用户。







###测试以及代码覆盖率

在实现功能前我们先针对我们要完成的功能编写相应的testcase，之后再进行功能的实现，**符合测试驱动开发的方法**，最后测试全部通过，符合我们的预期。代码覆盖率达到95%，

![DE5FF0B6D8D8328F78984AC1C10A0465](https://s3.ax1x.com/2021/01/12/sYsIiQ.jpg)

![F60E124FAA884CF3C6BDB41B58C2D79E](https://s3.ax1x.com/2021/01/12/sYsTRs.jpg)







![FE157EABEB2B0E0D032BBA33BAAE3847](https://s3.ax1x.com/2021/01/12/sYs4Ig.png)







###订单吞吐率和延迟

小表吞吐量：16532笔/秒

延迟：0.0232秒/笔

![image-20210112202142592](https://s3.ax1x.com/2021/01/12/sYsXZT.png)



大表吞吐量：17399笔/秒

延迟：0.0212秒/笔

![image-20210112202504120](https://s3.ax1x.com/2021/01/12/sYsbMq.png)



# 第四部分——版本控制

###git版本控制

我们在Viola-Siemens/bookstore下建仓库并clone项目，另外两位组员fork该仓库并以提交pull request请求的方式合作开发。

![image-20210112203148495](https://s3.ax1x.com/2021/01/12/sYsLLV.png)





![image-20210112203154157](https://s3.ax1x.com/2021/01/12/sYsoGj.png)



##团队分工

####刘冬煜：数据库设计、git版本控制、Buyer功能、收发货功能、自动取消订单功能、报告撰写、PPT制作

####翁思扬：数据库设计、Seller功能实现、搜索图书功能设计、分页查询设计优化、报告撰写、PPT制作

#### 孙印政：数据库设计、ER图设计、Auth功能实现、所有测试函数的编写、性能分析、吞吐量测试、报告撰写



